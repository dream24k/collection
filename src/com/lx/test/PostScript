为什么使用集合（数组的缺点）
    数组初始化之后，长度就不可变了，不便于扩展
    数组中提供的属性和方法少，不便于进行添加，删除，插入等操作，且效率不高
    数组存储的数据是有序的，可以重复的（存储数据的特点单一）

Java集合可分为Collection和Map两种体系
    Collection接口：单列数据，定义了存取一组对象的方法的集合
        List：元素有序，可重复的集合
        Set：元素无序，不可重复的集合
    Map接口：双列数据，保存具有映射关系“key-value对”的集合

ArrayList/LinkedList/Vector的异同？ArrayList底层是什么？扩容机制？Vector和ArrayList的区别？
    ArrayList和LinkedList的异同：
        二者都线程不安全，相对于线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态
        数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList优于
        LinkedList，因为LinkedList要移动指针。对于新增和删除操作add和remove，LinkedList比较
        占优势，因为ArrayList要移动数据。
    ArrayList和Vector的区别：
        Vector和ArrayList几乎是完全相同的，唯一的区别在于Vector是同步类，属于强同步类。因此
        开销就比ArrayList要大，访问要慢。正常情况下，大多数使用ArrayList而不是Vector，因为
        同步完全可以由程序员自己控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。
        Vector还有一个子类Stack。

Fail-Fast机制：如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException
                这就是fail-fast策略。

HashMap中put/get方法，HashMap的扩容机制，默认大小是多少？什么是负载因子(或填充比)，什么是吞吐临界值(或阈值，threshold)
    HashMap中的put方法：
        1，首先计算key的hash值，获取HashMap中的数组和数组长度，如果数组为空，初始化计算key的下标
        2，数组对应下标的位置是否为空，如果为空，则先添加一个，放在这个下标位置，然后判断数组内
        元素是否大于阈值，如果大于，则进行扩容
        3，如果数组对应下标不为空，则先获取对应链表的第一个值，判断hash和key是否相同，如果相同，
        新value替换旧value，返回旧value
        4，如果第一个值key不相同，判断当前链表是否为红黑树，如果是红黑树，调用红黑树链表put方法
        5，如果也不是红黑树，遍历链表，判断当前node是否是最后一个，如果是，说明链表中没有新添加的key，
        则在最后面新添加一个，然后判断是否超过阈值，如果超过，则转换红黑树
        6，如果不是最后一个，说明在中间已经存在key了，把新值赋值给旧值，判断是否需要扩容
    HashMap中的get方法：
        1，对输入的key的值计算hash值
        2，首先判断HashMap中的数组是否为空和数组的长度是否为0，如果为空和为0，则直接放回null
        3，如果不为空和0，计算key对于的数组下标，判断对应位置上的第一个node是否满足条件，
        如果满足条件，直接返回
        4，如果不满足条件，判断当前node是否是最后一个，如果是，说明不存在key，则返回null
        5，如果不是最后一个，判断是否是红黑树，如果是红黑树，则使用红黑树的方式获取对应的key
        6，如果不是红黑树，遍历链表是否有满足条件的，如果有，直接放回，否则返回null

    HashMap的扩容机制：
        1，空参数的构造函数：实例化的HashMap默认内部数组是null，即没有实例化，第一次调用put方法时，
        则会开始第一次初始化扩容，长度为16
        2，有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的2的幂数，将这个数
        设置复制给阈值。第一次调用put方法时，会将阈值赋值给容量，然后让阈值=容量*负载因子
        （因此并不是我们手动制定了容量就一定不会触发扩容，超过阈值后一样会扩容）
        3，如果不是第一次扩容，则容量变为原来的2倍，阈值也变为原来的2倍（容量和阈值都变为原来的2倍时，负载因子还是不变）
        注：首先put时，先回触发扩容（算是初始化），然后存入数据，然后判断是否需要扩容；不是首次put，
        则不在初始化，直接存入数据，然后判断是否需要扩容。

    负载因子：自动增加其哈希表容量之前允许哈希表获得的满度的度量
    负载因子的大小决定了HashMap的数据密度；
    负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入时的比较
    次数增多，性能会下降。
    负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就
    越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会
    影响性能，建议初始化预设大一点的空间。
    按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数

Map的实现类的结构：
    Map：双列数据，存储key-value对的数据。类似于高中的函数：y=f(x)
    HashMap：作为Map的主要实现类。线程不安全，效率高，存储null的key和value
    LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序实现遍历
        原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历
        操作，此类执行效率高于HashMap
    TreeMap：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序底层使用红黑树
    HashTable：作为古老的实现类，线程安全，效率低。不能存储null的key和value
    Properties：常用来处理配置文件，key和value都是String类型


